猜想结果是主进程阻塞直到父线程sleep结束，向两个子进程发送signal信号。输出会按照子进程，主进程的顺序输出，但是两个子进程输出的顺序不确定。
但是实际的运行结果是两个子进程会先输出，输出顺序不确定，等待5秒后父进程会输出。我还是用以前程序同步执行的思维在思考问题，忽视了CPU会进行进程的调度。当父进程sleep之后，CPU会先执行两个子进程，因此两个子进程会优先输出。父进程只有当sleep结束后才能继续执行剩余的语句。
按下Delete/quit键后父进程会立刻输出，因为按下键后会向父进程输送一个信号，父进程必须对该信号作出反应，也即发生中断，进入中断处理程序。但是由于一开始的stop函数并不会做出任何反应，因此父进程会立刻执行剩下的语句。
在子进程的代码中加上一个while(wait_flag);语句，并且在stop函数中添加wait_flag=0;的语句。修改之后由于wait_flag=1，while语句会一直循环知道wait_flag=0，也就是执行了stop函数之后也就是父进程发出信号之后，才能够进入子进程。

